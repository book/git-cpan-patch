#!/usr/bin/env perl

use 5.10.0;

use strict;
use warnings;

use autodie;

use File::Spec::Functions;
use File::Temp qw(tempdir);
use version;
use Git;

use CPANPLUS;
use Parse::BACKPAN::Packages;

$| = 1;

my $full_hist;

my $repo = Git->repository;

my ( $last_commit, $module, $last_version );

if ( @ARGV ) {
    $module = shift;
}

if ( $last_commit = eval { $repo->command_oneline("rev-parse", "-q", "--verify", "cpan/master") } ) {
    $module     ||= $repo->command_oneline("cpan-which");
    $last_version = $repo->command_oneline("cpan-last-version");
} else {
    $module ||= shift || die("Usage: git cpan-import Foo::Bar\n");
}

my $cpan = CPANPLUS::Backend->new;
my $module_obj = $cpan->parse_module( module => $module ) or die("No such module $module");

my $name    = $module_obj->name;
my $version = $module_obj->version;
my $dist    = $module_obj->package;
my $dist_name = join("-", $module_obj->package_name, $module_obj->package_version);

if ( $last_version ) {
    my $imported = version->new($last_version);
    my $will_import = version->new($module_obj->version);

    if ( $imported == $will_import ) {
        say "$dist_name has already been imported";
        exit;
    } elsif ( $imported > $will_import ) {
        die "imported version $imported is more recent than $will_import, can't import\n";
    } else {
        if ( $name ne $module ) {
            say "updating $name ($module) from $imported to $will_import";
        } else {
            say "updating $name from $imported to $will_import";
        }
    }
} else {
    if ( $name ne $module ) {
        say "importing $name ($module)";
    } else {
        say "importing $name";
    }
}

my $tmp_dir = tempdir;

say "downloading distribution";

my $location = $module_obj->fetch( fetchdir => $tmp_dir )
    or die "couldn't retrieve distribution file for module $module";

say "extracting distribution";

my $dir = $module_obj->extract( extractdir => $tmp_dir )
    or die "couldn't extract distribution file $location";

# create a tree object for the CPAN module
my $tree = do {
    # don't overwrite the user's index
    local $ENV{GIT_INDEX_FILE} = catfile($tmp_dir, "temp_git_index");
    local $ENV{GIT_DIR} = ".git";
    local $ENV{GIT_WORK_TREE} = $dir;

    my $write_tree_repo = Git->repository;

    $write_tree_repo->command( add => '.' );
    $write_tree_repo->command_oneline( "write-tree" );
};


say "opening backpan index";
my $backpan = Parse::BACKPAN::Packages->new;

my %dists = map { $_->filename => $_ } $backpan->distributions($module_obj->package_name);

{
    local $ENV{$_} for qw(GIT_AUTHOR_NAME GIT_AUTHOR_NAME GIT_AUTHOR_DATE);

    local $ENV{GIT_AUTHOR_DATE};

    my $author_obj = $module_obj->author;

    if ( my $bp_dist = $dists{$dist} ) {
        $ENV{GIT_AUTHOR_DATE} = $bp_dist->date;

        if ( $author_obj->isa("CPANPLUS::Module::Author::Fake") ) {
            $author_obj = $cpan->author_tree($bp_dist->cpanid);
        }
    } else {
        say "Couldn't find upload date for $dist";

        if ( $author_obj->isa("CPANPLUS::Module::Author::Fake") ) {
            say "Couldn't find author for $dist";
        }
    }

    $ENV{GIT_AUTHOR_NAME} = $author_obj->author;
    $ENV{GIT_AUTHOR_EMAIL} = $author_obj->email;

    # FIXME $repo->command_bidi_pipe is broken
    my ( $pid, $in, $out, $ctx ) = Git::command_bidi_pipe(
        "commit-tree", $tree,
        $last_commit ? ( "-p", $last_commit ) : (),
    );

    $out->print( join " ", ( $last_version ? "initial" : ()), "import $name $version from CPAN" );
    $out->print( join "\n", "", "git-cpan-module: $name", "git-cpan-version: $version", "" );

    close $out;
    open $out, "<", \my $buf; # kludge to avoid an error from close_bidi_pipe

    chomp(my $commit = <$in>);

    Git::command_close_bidi_pipe($pid, $in, $out, $ctx);

    $repo->command("update-ref", "-m" => "import $dist", "refs/remotes/cpan/master", $commit );

    $repo->command( tag => $version, $commit );
}

